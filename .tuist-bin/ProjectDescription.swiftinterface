// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
// swift-module-flags: -target x86_64-apple-macosx10.11 -enable-objc-interop -enable-library-evolution -swift-version 5 -O -module-name ProjectDescription
import Foundation
import Swift
public struct ArchiveAction : Swift.Equatable, Swift.Codable {
  public let configurationName: Swift.String
  public let revealArchiveInOrganizer: Swift.Bool
  public let customArchiveName: Swift.String?
  public let preActions: [ProjectDescription.ExecutionAction]
  public let postActions: [ProjectDescription.ExecutionAction]
  public init(configurationName: Swift.String, revealArchiveInOrganizer: Swift.Bool = true, customArchiveName: Swift.String? = nil, preActions: [ProjectDescription.ExecutionAction] = [], postActions: [ProjectDescription.ExecutionAction] = [])
  public static func == (a: ProjectDescription.ArchiveAction, b: ProjectDescription.ArchiveAction) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Arguments : Swift.Equatable, Swift.Codable {
  public let environment: [Swift.String : Swift.String]
  public let launch: [Swift.String : Swift.Bool]
  public init(environment: [Swift.String : Swift.String] = [:], launch: [Swift.String : Swift.Bool] = [:])
  public static func == (a: ProjectDescription.Arguments, b: ProjectDescription.Arguments) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct BuildAction : Swift.Equatable, Swift.Codable {
  public let targets: [ProjectDescription.TargetReference]
  public let preActions: [ProjectDescription.ExecutionAction]
  public let postActions: [ProjectDescription.ExecutionAction]
  public init(targets: [ProjectDescription.TargetReference], preActions: [ProjectDescription.ExecutionAction] = [], postActions: [ProjectDescription.ExecutionAction] = [])
  public static func == (a: ProjectDescription.BuildAction, b: ProjectDescription.BuildAction) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum CompatibleXcodeVersions : Swift.ExpressibleByArrayLiteral, Swift.ExpressibleByStringLiteral, Swift.Codable, Swift.Equatable {
  case all
  case list([Swift.String])
  public init(arrayLiteral elements: [Swift.String])
  public init(arrayLiteral elements: Swift.String...)
  public init(stringLiteral value: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
  public typealias ArrayLiteralElement = Swift.String
  public typealias StringLiteralType = Swift.String
  public static func == (a: ProjectDescription.CompatibleXcodeVersions, b: ProjectDescription.CompatibleXcodeVersions) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct CoreDataModel : Swift.Codable, Swift.Equatable {
  public let path: ProjectDescription.Path
  public let currentVersion: Swift.String
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case path
    case currentVersion
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(_ path: ProjectDescription.Path, currentVersion: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.CoreDataModel, b: ProjectDescription.CoreDataModel) -> Swift.Bool
}
public struct DeploymentDevice : Swift.OptionSet, Swift.Codable, Swift.Equatable {
  public static let iphone: ProjectDescription.DeploymentDevice
  public static let ipad: ProjectDescription.DeploymentDevice
  public static let mac: ProjectDescription.DeploymentDevice
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public typealias Element = ProjectDescription.DeploymentDevice
  public typealias ArrayLiteralElement = ProjectDescription.DeploymentDevice
}
public enum DeploymentTarget : Swift.Codable, Swift.Equatable {
  case iOS(targetVersion: Swift.String, devices: ProjectDescription.DeploymentDevice)
  case macOS(targetVersion: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.DeploymentTarget, b: ProjectDescription.DeploymentTarget) -> Swift.Bool
}
public struct ExecutionAction : Swift.Equatable, Swift.Codable {
  public let title: Swift.String
  public let scriptText: Swift.String
  public let target: ProjectDescription.TargetReference?
  public init(title: Swift.String = "Run Script", scriptText: Swift.String, target: ProjectDescription.TargetReference? = nil)
  public static func == (a: ProjectDescription.ExecutionAction, b: ProjectDescription.ExecutionAction) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum FileElement : Swift.Codable, Swift.Equatable {
  case glob(pattern: ProjectDescription.Path)
  case folderReference(path: ProjectDescription.Path)
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case type
    case pattern
    case path
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.FileElement, b: ProjectDescription.FileElement) -> Swift.Bool
}
extension FileElement : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Array : Swift.ExpressibleByUnicodeScalarLiteral where Element == ProjectDescription.FileElement {
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Array : Swift.ExpressibleByExtendedGraphemeClusterLiteral where Element == ProjectDescription.FileElement {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
}
extension Array : Swift.ExpressibleByStringLiteral where Element == ProjectDescription.FileElement {
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
}
public struct FileList : Swift.Codable, Swift.Equatable {
  public let globs: [ProjectDescription.Path]
  public init(globs: [ProjectDescription.Path])
  public static func == (lhs: ProjectDescription.FileList, rhs: ProjectDescription.FileList) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension FileList : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension FileList : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Swift.String...)
  public typealias ArrayLiteralElement = Swift.String
}
public struct Galaxy : Swift.Codable, Swift.Equatable {
  public let token: Swift.String
  public init(token: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Galaxy, b: ProjectDescription.Galaxy) -> Swift.Bool
}
public struct Headers : Swift.Codable, Swift.Equatable {
  public let `public`: ProjectDescription.FileList?
  public let `private`: ProjectDescription.FileList?
  public let project: ProjectDescription.FileList?
  public init(public: ProjectDescription.FileList? = nil, private: ProjectDescription.FileList? = nil, project: ProjectDescription.FileList? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Headers, b: ProjectDescription.Headers) -> Swift.Bool
}
public enum InfoPlist : Swift.Codable, Swift.Equatable {
  indirect public enum Value : Swift.Codable, Swift.Equatable {
    case string(Swift.String)
    case integer(Swift.Int)
    case boolean(Swift.Bool)
    case dictionary([Swift.String : ProjectDescription.InfoPlist.Value])
    case array([ProjectDescription.InfoPlist.Value])
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
    public static func == (lhs: ProjectDescription.InfoPlist.Value, rhs: ProjectDescription.InfoPlist.Value) -> Swift.Bool
  }
  case file(path: ProjectDescription.Path)
  case dictionary([Swift.String : ProjectDescription.InfoPlist.Value])
  case extendingDefault(with: [Swift.String : ProjectDescription.InfoPlist.Value])
  public static var `default`: ProjectDescription.InfoPlist {
    get
  }
  public enum CodingError : Swift.Error {
    case invalidType(Swift.String)
  }
  public static func == (lhs: ProjectDescription.InfoPlist, rhs: ProjectDescription.InfoPlist) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension InfoPlist : Swift.ExpressibleByStringLiteral, Swift.ExpressibleByUnicodeScalarLiteral, Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public typealias UnicodeScalarLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public init(stringLiteral value: Swift.String)
}
extension InfoPlist.Value : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension InfoPlist.Value : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension InfoPlist.Value : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension InfoPlist.Value : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, ProjectDescription.InfoPlist.Value)...)
  public typealias Key = Swift.String
  public typealias Value = ProjectDescription.InfoPlist.Value
}
extension InfoPlist.Value : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: ProjectDescription.InfoPlist.Value...)
  public typealias ArrayLiteralElement = ProjectDescription.InfoPlist.Value
}
public enum Package : Swift.Equatable, Swift.Codable {
  case remote(url: Swift.String, requirement: ProjectDescription.Package.Requirement)
  case local(path: ProjectDescription.Path)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Package, b: ProjectDescription.Package) -> Swift.Bool
}
extension Package {
  public enum Requirement : Swift.Codable, Swift.Equatable {
    case upToNextMajor(from: ProjectDescription.Version)
    case upToNextMinor(from: ProjectDescription.Version)
    case range(from: ProjectDescription.Version, to: ProjectDescription.Version)
    case exact(ProjectDescription.Version)
    case branch(Swift.String)
    case revision(Swift.String)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
    public static func == (a: ProjectDescription.Package.Requirement, b: ProjectDescription.Package.Requirement) -> Swift.Bool
  }
}
extension Package {
  public static func package(url: Swift.String, from version: ProjectDescription.Version) -> ProjectDescription.Package
  public static func package(url: Swift.String, _ requirement: ProjectDescription.Package.Requirement) -> ProjectDescription.Package
  public static func package(url: Swift.String, _ range: Swift.Range<ProjectDescription.Version>) -> ProjectDescription.Package
  public static func package(url: Swift.String, _ range: Swift.ClosedRange<ProjectDescription.Version>) -> ProjectDescription.Package
  public static func package(path: ProjectDescription.Path) -> ProjectDescription.Package
}
extension Package {
  @available(*, unavailable, message: "use package(url:_:) with the .exact(Version) initializer instead")
  public static func package(url _: Swift.String, version _: ProjectDescription.Version) -> ProjectDescription.Package
  @available(*, unavailable, message: "use package(url:_:) with the .branch(String) initializer instead")
  public static func package(url _: Swift.String, branch _: Swift.String) -> ProjectDescription.Package
  @available(*, unavailable, message: "use package(url:_:) with the .revision(String) initializer instead")
  public static func package(url _: Swift.String, revision _: Swift.String) -> ProjectDescription.Package
  @available(*, unavailable, message: "use package(url:_:) without the range label instead")
  public static func package(url _: Swift.String, range _: Swift.Range<ProjectDescription.Version>) -> ProjectDescription.Package
}
public struct Path : Swift.Codable, Swift.ExpressibleByStringLiteral, Swift.Equatable {
  public enum PathType : Swift.String, Swift.Codable {
    case relativeToCurrentFile
    case relativeToManifest
    case relativeToRoot
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: ProjectDescription.Path.PathType
  public let pathString: Swift.String
  public let callerPath: Swift.String?
  public init(_ path: Swift.String)
  public static func relativeToCurrentFile(_ pathString: Swift.String, callerPath: Swift.StaticString = #file) -> ProjectDescription.Path
  public static func relativeToManifest(_ pathString: Swift.String) -> ProjectDescription.Path
  public static func relativeToRoot(_ pathString: Swift.String) -> ProjectDescription.Path
  public init(stringLiteral: Swift.String)
  public static func == (a: ProjectDescription.Path, b: ProjectDescription.Path) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public enum Platform : Swift.String, Swift.Codable, Swift.Equatable {
  case iOS
  case macOS
  case watchOS
  case tvOS
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum PresetBuildConfiguration : Swift.String, Swift.Codable {
  case debug
  case release
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum Product : Swift.String, Swift.Codable, Swift.Equatable {
  case app
  case staticLibrary
  case dynamicLibrary
  case framework
  case staticFramework
  case unitTests
  case uiTests
  case bundle
  case appExtension
  case watch2App
  case watch2Extension
  case stickerPackExtension
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct Project : Swift.Codable, Swift.Equatable {
  public let name: Swift.String
  public let packages: [ProjectDescription.Package]
  public let targets: [ProjectDescription.Target]
  public let schemes: [ProjectDescription.Scheme]
  public let settings: ProjectDescription.Settings?
  public let additionalFiles: [ProjectDescription.FileElement]
  public init(name: Swift.String, packages: [ProjectDescription.Package] = [], settings: ProjectDescription.Settings? = nil, targets: [ProjectDescription.Target] = [], schemes: [ProjectDescription.Scheme] = [], additionalFiles: [ProjectDescription.FileElement] = [])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Project, b: ProjectDescription.Project) -> Swift.Bool
}
public struct RunAction : Swift.Equatable, Swift.Codable {
  public let configurationName: Swift.String
  public let executable: ProjectDescription.TargetReference?
  public let arguments: ProjectDescription.Arguments?
  public init(configurationName: Swift.String, executable: ProjectDescription.TargetReference? = nil, arguments: ProjectDescription.Arguments? = nil)
  public init(config: ProjectDescription.PresetBuildConfiguration = .debug, executable: ProjectDescription.TargetReference? = nil, arguments: ProjectDescription.Arguments? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.RunAction, b: ProjectDescription.RunAction) -> Swift.Bool
}
public struct Scheme : Swift.Equatable, Swift.Codable {
  public let name: Swift.String
  public let shared: Swift.Bool
  public let buildAction: ProjectDescription.BuildAction?
  public let testAction: ProjectDescription.TestAction?
  public let runAction: ProjectDescription.RunAction?
  public let archiveAction: ProjectDescription.ArchiveAction?
  public init(name: Swift.String, shared: Swift.Bool = true, buildAction: ProjectDescription.BuildAction? = nil, testAction: ProjectDescription.TestAction? = nil, runAction: ProjectDescription.RunAction? = nil, archiveAction: ProjectDescription.ArchiveAction? = nil)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Scheme, b: ProjectDescription.Scheme) -> Swift.Bool
}
public enum SettingValue : Swift.ExpressibleByStringLiteral, Swift.ExpressibleByArrayLiteral, Swift.Equatable, Swift.Codable {
  case string(Swift.String)
  case array([Swift.String])
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Swift.String...)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.SettingValue, b: ProjectDescription.SettingValue) -> Swift.Bool
  public typealias StringLiteralType = Swift.String
  public typealias ArrayLiteralElement = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct Configuration : Swift.Equatable, Swift.Codable {
  public let settings: [Swift.String : ProjectDescription.SettingValue]
  public let xcconfig: ProjectDescription.Path?
  public init(settings: [Swift.String : ProjectDescription.SettingValue] = [:], xcconfig: ProjectDescription.Path? = nil)
  @available(*, deprecated, message: "Please use init(settings: [String: SettingValue], xcconfig: String?) instead")
  public init(settings: [Swift.String : Swift.String], xcconfig: ProjectDescription.Path? = nil)
  public static func settings(_ settings: [Swift.String : ProjectDescription.SettingValue], xcconfig: ProjectDescription.Path? = nil) -> ProjectDescription.Configuration
  @available(*, deprecated, message: "Please use settings(_ settings: [String: SettingValue], xcconfig: String?)")
  public static func settings(_ settings: [Swift.String : Swift.String], xcconfig: ProjectDescription.Path? = nil) -> ProjectDescription.Configuration
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Configuration, b: ProjectDescription.Configuration) -> Swift.Bool
}
public struct CustomConfiguration : Swift.Equatable, Swift.Codable {
  public enum Variant : Swift.String, Swift.Codable {
    case debug
    case release
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let variant: ProjectDescription.CustomConfiguration.Variant
  public let configuration: ProjectDescription.Configuration?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.CustomConfiguration, b: ProjectDescription.CustomConfiguration) -> Swift.Bool
}
extension CustomConfiguration {
  public static func debug(name: Swift.String, settings: [Swift.String : ProjectDescription.SettingValue] = [:], xcconfig: ProjectDescription.Path? = nil) -> ProjectDescription.CustomConfiguration
  @available(*, deprecated, message: "Please use debug(name: String, settings: [String: SettingValue], xcconfig: String?) instead")
  public static func debug(name: Swift.String, settings: [Swift.String : Swift.String], xcconfig: ProjectDescription.Path? = nil) -> ProjectDescription.CustomConfiguration
  public static func release(name: Swift.String, settings: [Swift.String : ProjectDescription.SettingValue] = [:], xcconfig: ProjectDescription.Path? = nil) -> ProjectDescription.CustomConfiguration
  @available(*, deprecated, message: "Please use release(name: String, settings: [String: SettingValue], xcconfig: String?) instead")
  public static func release(name: Swift.String, settings: [Swift.String : Swift.String], xcconfig: ProjectDescription.Path? = nil) -> ProjectDescription.CustomConfiguration
}
public enum DefaultSettings : Swift.String, Swift.Codable {
  case recommended
  case essential
  case none
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct Settings : Swift.Equatable, Swift.Codable {
  public let base: [Swift.String : ProjectDescription.SettingValue]
  public let configurations: [ProjectDescription.CustomConfiguration]
  public let defaultSettings: ProjectDescription.DefaultSettings
  public init(base: [Swift.String : ProjectDescription.SettingValue] = [:], debug: ProjectDescription.Configuration? = nil, release: ProjectDescription.Configuration? = nil, defaultSettings: ProjectDescription.DefaultSettings = .recommended)
  @available(*, deprecated, message: "Please use init(base: [String: SettingValue], debug: Configuration?, release: Configuration?, defaultSettings: DefaultSettings) instead")
  public init(base: [Swift.String : Swift.String], debug: ProjectDescription.Configuration? = nil, release: ProjectDescription.Configuration? = nil, defaultSettings: ProjectDescription.DefaultSettings = .recommended)
  public init(base: [Swift.String : ProjectDescription.SettingValue] = [:], configurations: [ProjectDescription.CustomConfiguration], defaultSettings: ProjectDescription.DefaultSettings = .recommended)
  @available(*, deprecated, message: "Please use init(base: [String: SettingValue], configurations: [CustomConfiguration], defaultSettings: DefaultSettings) instead")
  public init(base: [Swift.String : Swift.String], configurations: [ProjectDescription.CustomConfiguration], defaultSettings: ProjectDescription.DefaultSettings = .recommended)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Settings, b: ProjectDescription.Settings) -> Swift.Bool
}
public struct Setup : Swift.Codable, Swift.Equatable {
  public let actions: [ProjectDescription.Up]
  public init(_ actions: [ProjectDescription.Up])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Setup, b: ProjectDescription.Setup) -> Swift.Bool
}
public struct SourceFileGlob : Swift.ExpressibleByStringLiteral, Swift.Codable, Swift.Equatable {
  public let glob: ProjectDescription.Path
  public let excluding: [ProjectDescription.Path]
  public let compilerFlags: Swift.String?
  public init(_ glob: ProjectDescription.Path, excluding: [ProjectDescription.Path] = [], compilerFlags: Swift.String? = nil)
  public init(_ glob: ProjectDescription.Path, excluding: ProjectDescription.Path?, compilerFlags: Swift.String? = nil)
  public init(stringLiteral value: Swift.String)
  public static func == (a: ProjectDescription.SourceFileGlob, b: ProjectDescription.SourceFileGlob) -> Swift.Bool
  public typealias StringLiteralType = Swift.String
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct SourceFilesList : Swift.Codable, Swift.Equatable {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case globs
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public let globs: [ProjectDescription.SourceFileGlob]
  public init(globs: [ProjectDescription.SourceFileGlob])
  public init(globs: [Swift.String])
  public static func paths(_ paths: [ProjectDescription.Path]) -> ProjectDescription.SourceFilesList
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.SourceFilesList, b: ProjectDescription.SourceFilesList) -> Swift.Bool
}
extension SourceFilesList : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension SourceFilesList : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: ProjectDescription.SourceFileGlob...)
  public typealias ArrayLiteralElement = ProjectDescription.SourceFileGlob
}
public struct Target : Swift.Codable, Swift.Equatable {
  public let name: Swift.String
  public let platform: ProjectDescription.Platform
  public let product: ProjectDescription.Product
  public let bundleId: Swift.String
  public let productName: Swift.String?
  public let deploymentTarget: ProjectDescription.DeploymentTarget?
  public let infoPlist: ProjectDescription.InfoPlist
  public let entitlements: ProjectDescription.Path?
  public let settings: ProjectDescription.Settings?
  public let dependencies: [ProjectDescription.TargetDependency]
  public let sources: ProjectDescription.SourceFilesList?
  public let resources: [ProjectDescription.FileElement]?
  public let headers: ProjectDescription.Headers?
  public let actions: [ProjectDescription.TargetAction]
  public let coreDataModels: [ProjectDescription.CoreDataModel]
  public let environment: [Swift.String : Swift.String]
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case name
    case platform
    case product
    case productName
    case bundleId
    case infoPlist
    case entitlements
    case settings
    case dependencies
    case sources
    case resources
    case headers
    case coreDataModels
    case actions
    case environment
    case deploymentTarget
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public init(name: Swift.String, platform: ProjectDescription.Platform, product: ProjectDescription.Product, productName: Swift.String? = nil, bundleId: Swift.String, deploymentTarget: ProjectDescription.DeploymentTarget? = nil, infoPlist: ProjectDescription.InfoPlist, sources: ProjectDescription.SourceFilesList? = nil, resources: [ProjectDescription.FileElement]? = nil, headers: ProjectDescription.Headers? = nil, entitlements: ProjectDescription.Path? = nil, actions: [ProjectDescription.TargetAction] = [], dependencies: [ProjectDescription.TargetDependency] = [], settings: ProjectDescription.Settings? = nil, coreDataModels: [ProjectDescription.CoreDataModel] = [], environment: [Swift.String : Swift.String] = [:])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Target, b: ProjectDescription.Target) -> Swift.Bool
}
public struct TargetAction : Swift.Codable, Swift.Equatable {
  public enum Order : Swift.String, Swift.Codable, Swift.Equatable {
    case pre
    case post
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: Swift.String
  public let tool: Swift.String?
  public let path: ProjectDescription.Path?
  public let order: ProjectDescription.TargetAction.Order
  public let arguments: [Swift.String]
  public let inputPaths: [ProjectDescription.Path]
  public let inputFileListPaths: [ProjectDescription.Path]
  public let outputPaths: [ProjectDescription.Path]
  public let outputFileListPaths: [ProjectDescription.Path]
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case name
    case tool
    case path
    case order
    case arguments
    case inputPaths
    case inputFileListPaths
    case outputPaths
    case outputFileListPaths
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public static func pre(tool: Swift.String, arguments: Swift.String..., name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public static func pre(tool: Swift.String, arguments: [Swift.String], name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public static func pre(path: ProjectDescription.Path, arguments: Swift.String..., name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public static func pre(path: ProjectDescription.Path, arguments: [Swift.String], name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public static func post(tool: Swift.String, arguments: Swift.String..., name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public static func post(tool: Swift.String, arguments: [Swift.String], name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public static func post(path: ProjectDescription.Path, arguments: Swift.String..., name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public static func post(path: ProjectDescription.Path, arguments: [Swift.String], name: Swift.String, inputPaths: [ProjectDescription.Path] = [], inputFileListPaths: [ProjectDescription.Path] = [], outputPaths: [ProjectDescription.Path] = [], outputFileListPaths: [ProjectDescription.Path] = []) -> ProjectDescription.TargetAction
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.TargetAction, b: ProjectDescription.TargetAction) -> Swift.Bool
}
public enum SDKStatus : Swift.String {
  case required
  case optional
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum TargetDependency : Swift.Codable, Swift.Equatable {
  case target(name: Swift.String)
  case project(target: Swift.String, path: ProjectDescription.Path)
  case framework(path: ProjectDescription.Path)
  case library(path: ProjectDescription.Path, publicHeaders: ProjectDescription.Path, swiftModuleMap: ProjectDescription.Path?)
  case package(product: Swift.String)
  case sdk(name: Swift.String, status: ProjectDescription.SDKStatus)
  case cocoapods(path: ProjectDescription.Path)
  case xcFramework(path: ProjectDescription.Path)
  public static func sdk(name: Swift.String) -> ProjectDescription.TargetDependency
  public var typeName: Swift.String {
    get
  }
  public static func == (a: ProjectDescription.TargetDependency, b: ProjectDescription.TargetDependency) -> Swift.Bool
}
extension SDKStatus : Swift.Codable {
}
extension TargetDependency {
  public enum CodingError : Swift.Error {
    case unknownType(Swift.String)
  }
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case type
    case name
    case target
    case path
    case url
    case productName
    case versionRequirement
    case publicHeaders
    case swiftModuleMap
    case status
    case package
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct TargetReference : Swift.Equatable, Swift.Codable, Swift.ExpressibleByStringLiteral {
  public var projectPath: ProjectDescription.Path?
  public var targetName: Swift.String
  public init(projectPath: ProjectDescription.Path?, target: Swift.String)
  public init(stringLiteral value: Swift.String)
  public static func project(path: ProjectDescription.Path, target: Swift.String) -> ProjectDescription.TargetReference
  public static func == (a: ProjectDescription.TargetReference, b: ProjectDescription.TargetReference) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct TemplateString : Swift.Encodable, Swift.Decodable, Swift.Equatable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: ProjectDescription.TemplateString, b: ProjectDescription.TemplateString) -> Swift.Bool
}
extension TemplateString : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral: Swift.String)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension TemplateString : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension TemplateString : Swift.ExpressibleByStringInterpolation {
  public init(stringInterpolation: ProjectDescription.TemplateString.StringInterpolation)
  public struct StringInterpolation : Swift.StringInterpolationProtocol {
    public init(literalCapacity _: Swift.Int, interpolationCount _: Swift.Int)
    mutating public func appendLiteral(_ literal: Swift.String)
    mutating public func appendInterpolation(_ token: ProjectDescription.TemplateString.Token)
    public typealias StringLiteralType = Swift.String
  }
}
extension TemplateString {
  public enum Token : Swift.String {
    case projectName
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
public func == (lhs: ProjectDescription.TemplateString.Token, rhs: ProjectDescription.TemplateString.Token) -> Swift.Bool
public struct TestAction : Swift.Equatable, Swift.Codable {
  public let targets: [ProjectDescription.TestableTarget]
  public let arguments: ProjectDescription.Arguments?
  public let configurationName: Swift.String
  public let coverage: Swift.Bool
  public let codeCoverageTargets: [ProjectDescription.TargetReference]
  public let preActions: [ProjectDescription.ExecutionAction]
  public let postActions: [ProjectDescription.ExecutionAction]
  public init(targets: [ProjectDescription.TestableTarget] = [], arguments: ProjectDescription.Arguments? = nil, configurationName: Swift.String, coverage: Swift.Bool = false, codeCoverageTargets: [ProjectDescription.TargetReference] = [], preActions: [ProjectDescription.ExecutionAction] = [], postActions: [ProjectDescription.ExecutionAction] = [])
  public init(targets: [ProjectDescription.TestableTarget], arguments: ProjectDescription.Arguments? = nil, config: ProjectDescription.PresetBuildConfiguration = .debug, coverage: Swift.Bool = false, codeCoverageTargets: [ProjectDescription.TargetReference] = [], preActions: [ProjectDescription.ExecutionAction] = [], postActions: [ProjectDescription.ExecutionAction] = [])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.TestAction, b: ProjectDescription.TestAction) -> Swift.Bool
}
public struct TestableTarget : Swift.Equatable, Swift.Codable, Swift.ExpressibleByStringLiteral {
  public let target: ProjectDescription.TargetReference
  public let isSkipped: Swift.Bool
  public let isParallelizable: Swift.Bool
  public let isRandomExecutionOrdering: Swift.Bool
  public init(target: ProjectDescription.TargetReference, skipped: Swift.Bool = false, parallelizable: Swift.Bool = false, randomExecutionOrdering: Swift.Bool = false)
  public init(stringLiteral value: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.TestableTarget, b: ProjectDescription.TestableTarget) -> Swift.Bool
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct TuistConfig : Swift.Codable, Swift.Equatable {
  public enum GenerationOptions : Swift.Encodable, Swift.Decodable, Swift.Equatable {
    case xcodeProjectName(ProjectDescription.TemplateString)
  }
  public let generationOptions: [ProjectDescription.TuistConfig.GenerationOptions]
  public let compatibleXcodeVersions: ProjectDescription.CompatibleXcodeVersions
  public init(compatibleXcodeVersions: ProjectDescription.CompatibleXcodeVersions = .all, generationOptions: [ProjectDescription.TuistConfig.GenerationOptions])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension TuistConfig.GenerationOptions {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public func == (lhs: ProjectDescription.TuistConfig, rhs: ProjectDescription.TuistConfig) -> Swift.Bool
public func == (lhs: ProjectDescription.TuistConfig.GenerationOptions, rhs: ProjectDescription.TuistConfig.GenerationOptions) -> Swift.Bool
public class Up : Swift.Codable, Swift.Equatable {
  public static func homebrew(packages: [Swift.String]) -> ProjectDescription.Up
  public static func homebrewTap(repositories: [Swift.String]) -> ProjectDescription.Up
  public static func custom(name: Swift.String, meet: [Swift.String], isMet: [Swift.String]) -> ProjectDescription.Up
  public static func carthage(platforms: [ProjectDescription.Platform]? = nil) -> ProjectDescription.Up
  public static func == (_: ProjectDescription.Up, _: ProjectDescription.Up) -> Swift.Bool
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Version : Swift.Hashable {
  public let major: Swift.Int
  public let minor: Swift.Int
  public let patch: Swift.Int
  public let prereleaseIdentifiers: [Swift.String]
  public let buildMetadataIdentifiers: [Swift.String]
  public init(_ major: Swift.Int, _ minor: Swift.Int, _ patch: Swift.Int, prereleaseIdentifiers: [Swift.String] = [], buildMetadataIdentifiers: [Swift.String] = [])
  public static func == (a: ProjectDescription.Version, b: ProjectDescription.Version) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Version : Swift.Comparable {
  public static func < (lhs: ProjectDescription.Version, rhs: ProjectDescription.Version) -> Swift.Bool
}
extension Version : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Version {
  public init?(string: Swift.String)
}
extension Version : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(unicodeScalarLiteral value: Swift.String)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Version : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension ClosedRange where Bound == ProjectDescription.Version {
  public func contains(_: ProjectDescription.Version) -> Swift.Bool
}
extension Range where Bound == ProjectDescription.Version {
  public func contains(_: ProjectDescription.Version) -> Swift.Bool
}
extension Range where Bound == ProjectDescription.Version {
  public func contains(version: ProjectDescription.Version) -> Swift.Bool
}
public struct Workspace : Swift.Codable, Swift.Equatable {
  public let name: Swift.String
  public let projects: [ProjectDescription.Path]
  public let schemes: [ProjectDescription.Scheme]
  public let additionalFiles: [ProjectDescription.FileElement]
  public init(name: Swift.String, projects: [ProjectDescription.Path], schemes: [ProjectDescription.Scheme] = [], additionalFiles: [ProjectDescription.FileElement] = [])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ProjectDescription.Workspace, b: ProjectDescription.Workspace) -> Swift.Bool
}
extension ProjectDescription.CoreDataModel.CodingKeys : Swift.Equatable {}
extension ProjectDescription.CoreDataModel.CodingKeys : Swift.Hashable {}
extension ProjectDescription.CoreDataModel.CodingKeys : Swift.RawRepresentable {}
extension ProjectDescription.FileElement.CodingKeys : Swift.Equatable {}
extension ProjectDescription.FileElement.CodingKeys : Swift.Hashable {}
extension ProjectDescription.FileElement.CodingKeys : Swift.RawRepresentable {}
extension ProjectDescription.Path.PathType : Swift.Equatable {}
extension ProjectDescription.Path.PathType : Swift.Hashable {}
extension ProjectDescription.Path.PathType : Swift.RawRepresentable {}
extension ProjectDescription.Platform : Swift.Hashable {}
extension ProjectDescription.Platform : Swift.RawRepresentable {}
extension ProjectDescription.PresetBuildConfiguration : Swift.Equatable {}
extension ProjectDescription.PresetBuildConfiguration : Swift.Hashable {}
extension ProjectDescription.PresetBuildConfiguration : Swift.RawRepresentable {}
extension ProjectDescription.Product : Swift.Hashable {}
extension ProjectDescription.Product : Swift.RawRepresentable {}
extension ProjectDescription.CustomConfiguration.Variant : Swift.Hashable {}
extension ProjectDescription.CustomConfiguration.Variant : Swift.RawRepresentable {}
extension ProjectDescription.DefaultSettings : Swift.Hashable {}
extension ProjectDescription.DefaultSettings : Swift.RawRepresentable {}
extension ProjectDescription.SourceFilesList.CodingKeys : Swift.Equatable {}
extension ProjectDescription.SourceFilesList.CodingKeys : Swift.Hashable {}
extension ProjectDescription.SourceFilesList.CodingKeys : Swift.RawRepresentable {}
extension ProjectDescription.Target.CodingKeys : Swift.Equatable {}
extension ProjectDescription.Target.CodingKeys : Swift.Hashable {}
extension ProjectDescription.Target.CodingKeys : Swift.RawRepresentable {}
extension ProjectDescription.TargetAction.Order : Swift.Hashable {}
extension ProjectDescription.TargetAction.Order : Swift.RawRepresentable {}
extension ProjectDescription.TargetAction.CodingKeys : Swift.Equatable {}
extension ProjectDescription.TargetAction.CodingKeys : Swift.Hashable {}
extension ProjectDescription.TargetAction.CodingKeys : Swift.RawRepresentable {}
extension ProjectDescription.SDKStatus : Swift.Equatable {}
extension ProjectDescription.SDKStatus : Swift.Hashable {}
extension ProjectDescription.SDKStatus : Swift.RawRepresentable {}
extension ProjectDescription.TargetDependency.CodingKeys : Swift.Equatable {}
extension ProjectDescription.TargetDependency.CodingKeys : Swift.Hashable {}
extension ProjectDescription.TargetDependency.CodingKeys : Swift.RawRepresentable {}
extension ProjectDescription.TemplateString.Token : Swift.Equatable {}
extension ProjectDescription.TemplateString.Token : Swift.Hashable {}
extension ProjectDescription.TemplateString.Token : Swift.RawRepresentable {}
